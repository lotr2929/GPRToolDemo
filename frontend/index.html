<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GPRTool Demo</title>

  <!-- External stylesheet (contains all colour tokens) -->
  <link rel="stylesheet" href="styles.css" />

  <!-- Resolve bare specifier 'three' to your local module -->
  <script type="importmap">
  {
    "imports": {
      "three": "./js/three.module.js"
    }
  }
  </script>

  <style>
    /* ==== Layout only (no colours here) ==== */
    html, body { height: 100%; margin: 0; }

    body {
      display: flex;
      flex-direction: column;
      font-family: system-ui, Segoe UI, Arial, sans-serif;
    }

    #header-container { flex: 0 0 auto; width: 100%; }

    #body-container {
      flex: 1 1 auto;
      min-height: 0;
      width: 100%;
      overflow: hidden;
      height: 100%;
      position: relative;
    }

    /* Ensure viewport consumes full remaining height */
    .page-wrap { height: 100%; }
    .scene-layout { height: 100%; min-height: 0; }
    .viewport { height: 100% !important; min-height: 0 !important; }

    #three-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>

<body>

  <div id="header-container"></div>
  <div id="body-container"></div>

  <script type="module">
    /* ========================
       0) Module imports
       ======================== */
    const THREE = await import('three');
    const { OrbitControls } = await import('./js/OrbitControls.js');


    /* ========================
       1) Load header + body
       ======================== */
    const header = await fetch('header.html').then(r => r.text());
    document.getElementById('header-container').innerHTML = header;

    function updateHeaderTime() {
      const el = document.getElementById('header-datetime');
      if (el) el.textContent = new Date().toLocaleString();
    }
    updateHeaderTime();
    setInterval(updateHeaderTime, 1000);

    const bodyHTML = await fetch('body.html').then(r => r.text());
    document.getElementById('body-container').innerHTML = bodyHTML;


    /* ========================
       1.5) Auto-fit viewport height
       ======================== */
    (function ensureViewportHeightFits() {
      const bodyContainer = document.getElementById('body-container');
      const layout = document.querySelector('.scene-layout');
      const viewport = document.querySelector('.viewport');
      if (!bodyContainer || !layout || !viewport) return;

      function applyHeight() {
        const cs = getComputedStyle(layout);
        const vPad = (parseFloat(cs.paddingTop) || 0) +
                     (parseFloat(cs.paddingBottom) || 0);
        const h = Math.max(320, bodyContainer.clientHeight - vPad);
        viewport.style.height = h + 'px';
        viewport.style.minHeight = '0px';
      }

      const ro = new ResizeObserver(applyHeight);
      ro.observe(bodyContainer);
      ro.observe(layout);
      addEventListener('resize', applyHeight, { passive: true });
      applyHeight();
    })();


    /* ========================
       2) DOM hooks
       ======================== */
    const canvas = document.getElementById('three-canvas');
    if (!canvas) throw new Error('No #three-canvas found.');

    const container = canvas.parentElement;

    const xIn = document.getElementById('widthX');
    const yIn = document.getElementById('heightY');
    const zIn = document.getElementById('depthZ');
    const resetBtn = document.getElementById('resetBtn');


    /* ========================
       3) Renderer, scene, camera
       ======================== */
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();

    /* === Viewport background from CSS token === */
    function applyViewportBackground() {
      const styles = getComputedStyle(document.documentElement);
      const cssColor = styles.getPropertyValue('--vp-bgcolor').trim() || '#0b1222';
      renderer.setClearColor(new THREE.Color(cssColor), 1.0);
    }
    applyViewportBackground();

    /* Optional: auto-update if data-theme changes */
    new MutationObserver(applyViewportBackground)
      .observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme']
      });

    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 1000);
    camera.position.set(1.5, 1.5, 1.5);
    camera.updateProjectionMatrix();

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ===== smoother feel + limits to prevent flips/zoom-through =====
    controls.dampingFactor = 0.08;
    controls.rotateSpeed   = 0.6;
    controls.zoomSpeed     = 0.8;

    controls.minDistance   = 0.4;
    controls.maxDistance   = 50;

    controls.minPolarAngle = 0.01;
    controls.maxPolarAngle = Math.PI - 0.01;

    // ===== keep auto-rotate, but pause while user interacts =====
    const ROT_X = 0.6;  // radians per second
    const ROT_Y = 0.8;
    let userInteracting = false;
    controls.addEventListener('start', () => { userInteracting = true;  });
    controls.addEventListener('end',   () => { userInteracting = false; });


    /* ========================
       4) Lights
       ======================== */
    const keyLight = new THREE.DirectionalLight(0xffffff, 1);
    keyLight.position.set(2, 3, 4);
    scene.add(keyLight, new THREE.AmbientLight(0xffffff, 0.25));


    /* ========================
       4.5) Camera fit helper
       ======================== */
    // Preserves current view direction; adjusts only distance + planes
    function fitCameraToObject({ camera, object, controls, padding = 2 }) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);

      const radius    = 0.5 * Math.max(size.x, size.y, size.z);
      const fitRadius = radius * padding;

      const fov    = THREE.MathUtils.degToRad(camera.fov);
      const aspect = camera.aspect || 1;

      const distV = fitRadius / Math.sin(fov / 2);
      const distH = fitRadius / Math.sin(Math.atan(Math.tan(fov / 2) * aspect));
      const distance = Math.max(distV, distH);

      // Preserve current orbit angles; adjust only distance
      const fromTarget = new THREE.Vector3().copy(camera.position).sub(controls.target);
      const spherical  = new THREE.Spherical().setFromVector3(fromTarget);
      spherical.radius = distance;

      // New target is the object's center
      controls.target.copy(center);
      const newOffset = new THREE.Vector3().setFromSpherical(spherical);
      camera.position.copy(controls.target).add(newOffset);

      // Tighten camera planes to reduce clipping/fighting
      camera.near = Math.max(0.01, distance - fitRadius * 2);
      camera.far  = distance + fitRadius * 2;
      camera.updateProjectionMatrix();

      controls.update();
    }

    // Keep near/far in sync as object size changes, without refitting every keystroke
    function updateCameraPlanesForObject(object, padding = 2) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3(); box.getSize(size);
      const radius    = 0.5 * Math.max(size.x, size.y, size.z);
      const fitRadius = radius * padding;

      const distance = camera.position.distanceTo(controls.target);
      camera.near = Math.max(0.01, distance - fitRadius * 2);
      camera.far  = distance + fitRadius * 2;
      camera.updateProjectionMatrix();
    }


    /* ========================
       5) Cube with plywood texture
       ======================== */
    const cubeGeom = new THREE.BoxGeometry(1, 1, 1);

    let woodMat;
    try {
      const tex = new THREE.TextureLoader().load('./textures/plywood.webp');
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

      woodMat = new THREE.MeshStandardMaterial({
        map: tex,
        metalness: 0,
        roughness: 0.6
      });
    } catch {
      woodMat = new THREE.MeshNormalMaterial();
      console.warn('Using fallback material.');
    }

    const cube = new THREE.Mesh(cubeGeom, woodMat);
    scene.add(cube);

    /* (Removed initial fit here â€” it now runs after the first resize) */


    /* ========================
       6) Resize to container
       ======================== */
    function resizeToContainer() {
      const w = container.clientWidth  || 1;
      const h = container.clientHeight || 1;

      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      controls.update();
      
    }
    new ResizeObserver(resizeToContainer).observe(container);
    addEventListener('resize', resizeToContainer);
    resizeToContainer();

    // Initial fit AFTER first resize (so aspect is correct)
    fitCameraToObject({ camera, object: cube, controls, padding: 2 });

    /* ========================
       7) Input controls
       ======================== */
    function applyScale() {
      const x = Math.max(0.1, parseFloat(xIn?.value) || 1);
      const y = Math.max(0.1, parseFloat(yIn?.value) || 1);
      const z = Math.max(0.1, parseFloat(zIn?.value) || 1);

      cube.scale.set(x, y, z);

      // keep camera planes appropriate for new size
      updateCameraPlanesForObject(cube);

      const map = woodMat?.map;
      if (map?.repeat) {
        map.repeat.set(Math.max(1, x), Math.max(1, y));
        map.needsUpdate = true;
      }
    }

    if (xIn && yIn && zIn) {
      ['input', 'change'].forEach(ev => {
        xIn.addEventListener(ev, applyScale);
        yIn.addEventListener(ev, applyScale);
        zIn.addEventListener(ev, applyScale);
      });
    }

    resetBtn?.addEventListener('click', () => {
      xIn.value = yIn.value = zIn.value = '1';
      applyScale();
      fitCameraToObject({ camera, object: cube, controls, padding: 2 });
    });

    applyScale();


    /* ========================
       8) Animation Loop
       ======================== */
    // Delta time + pause while interacting
    const clock = new THREE.Clock();
    (function animate() {
      const dt = clock.getDelta();

      // Gentle auto-rotate unless user is interacting
      if (!userInteracting) {
        //cube.rotation.x += dt * ROT_X;
        //cube.rotation.y += dt * ROT_Y;
      }

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    })();
  </script>

</body>
</html>